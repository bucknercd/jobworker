syntax = "proto3";

package jobworker.v1;

option go_package = "github.com/bucknercd/jobworker/proto/gen/jobpb;jobpb";

// ================= Enums =================

// Execution status for a job.
// Matches internal server statuses: UNKNOWN, RUNNING, EXITED, STOPPED, FAILED.
enum JobStatus {
  JOB_STATUS_UNSPECIFIED = 0; // Unknown or not yet set
  JOB_STATUS_RUNNING     = 1;
  JOB_STATUS_EXITED      = 2;
  JOB_STATUS_STOPPED     = 3;
  JOB_STATUS_FAILED      = 4;
}

// Output target to stream.
// Defaults to STDOUT if not set.
enum StreamTarget {
    STDOUT = 0;
    STDERR = 1;
}

// ================= Limits =================
//
// Units and accepted forms:
//   cpu         = "500m" (millicores), "2" (whole cores), "max" (unlimited)
//   memory_max  = "100M" (bytes w/ suffix), "max" (unlimited)
//   io_class    = "low" | "med" | "high"
//
// Mapping to cgroups v2 (see design doc for full table):
//   --cpu=<val>   -> cpu.max
//   --memory=<val> -> memory.max
//   --io=<profile> -> io.max
message ResourceLimits {
  string cpu         = 1;
  string memory_max  = 2;
  string io_class    = 3;
}

// ================= Requests / Responses =================

// Metadata about a job.
// AuthZ note: `user`, `role`, and `group` are derived from the client mTLS cert
// (CN, OUs) — clients cannot set these values directly.
message JobMetadata {
  string    user      = 1; // From mTLS CN
  JobStatus status    = 2;
  int32     exit_code = 3; // Set if status = EXITED or FAILED
}

// Starts a new job.
// The executable will run inside a chroot jail with a safe PATH (/usr/bin:/bin),
// dropped privileges (nobody:nogroup by default), and cgroup v2 resource limits.
// The executable may be absolute or resolved from the safe PATH.
message StartJobRequest {
  string           executable = 1;           // e.g. "ls" or "/usr/bin/ls"
  repeated string  args       = 2;           // e.g. ["-lah", "/"]
  ResourceLimits   limits     = 3;           // Empty => apply server defaults
}

// Response with the generated job ID.
// Format: 16-character lowercase [a-z0-9], lexicographically sortable:
//   first 6 = fixed-width base36 Unix timestamp (rightmost if longer),
//   last 10 = crypto-random chars.
// Example: "0abcde1234567890"
message StartJobResponse {
  string job_id = 1;
}

message StopJobRequest {
  string job_id = 1;
}

message StopJobResponse {
  JobMetadata metadata = 1;
}

message GetStatusRequest {
  string job_id = 1;
}

message GetStatusResponse {
  string      job_id   = 1;
  JobMetadata metadata = 2;
}

// ================= Streaming =================
//
// Server streams from the beginning of the selected output (stdout by default)
// and continues in real-time until the writer closes the FD (job exit) or the
// call ends. Replay is supported even after job exit — output persists on disk
// until TTL expiry.
//
// Multiple clients may stream the same job concurrently.
message StreamOutputRequest {
  string job_id        = 1;
  StreamTarget target  = 2; // Optional; defaults to STDOUT
}

message StreamOutputResponse {
  bytes  chunk         = 1; // Up to server chunk size (e.g., 32KB)
}

// ================= Service =================
//
// Error model (gRPC status codes):
//   INVALID_ARGUMENT     bad executable/args/limits
//   PERMISSION_DENIED    caller not allowed (role/group/allowlist)
//   NOT_FOUND            unknown job_id
//   FAILED_PRECONDITION  environment not ready (e.g., cgroup FS missing)
//   RESOURCE_EXHAUSTED   guardrails hit (max jobs, etc.)
//   UNAVAILABLE          service not ready/backpressure
//   INTERNAL             unexpected server error
service JobWorker {
  rpc StartJob     (StartJobRequest)      returns (StartJobResponse);
  rpc StopJob      (StopJobRequest)       returns (StopJobResponse);
  rpc GetStatus    (GetStatusRequest)     returns (GetStatusResponse);
  rpc StreamOutput (StreamOutputRequest)  returns (stream StreamOutputResponse);
}
